#4
===

처음 문제를 보면 어떤 문구가 적혀있고 그 아래 패스워드를 적는 칸이 놓여있다.

![](https://postfiles.pstatic.net/MjAyMDAxMTlfMjM2/MDAxNTc5NDEyMTE3NjIy.tRNx2vZfR_bjwpz80qgW7dSNAwMs6lXnJnU85xQaVCUg.RJ7M9mhS-YpQQFoVlwI9D-z_mJwjl9CXysRWE4L7nhMg.JPEG.rlaeoghks823/K-070.jpg?type=w773)

적혀있는 문구는 무언가 암호화 된 것으로 보이며 이걸 복호화해서 password에 넣으면 문제가 해결될 줄 알았다.

일단 아무값이나 패스워드에 넣으니 아래와 같이 문구가 바뀌었다.

![](https://postfiles.pstatic.net/MjAyMDAxMTlfOCAg/MDAxNTc5NDEyMTE5Nzk5.sbAEVP-5FZh1Z5KNB4ySaEGi_Qfi-6JiRv4PjHY68Ncg.H7AeLH-VxnwIfcf4E1ncmNG8Gmu454qQCbRP9ovFADQg.JPEG.rlaeoghks823/K-071.jpg?type=w773)

더 자세한 상황을 알기 위해 소스코드를 살펴보았다.

```php
<?php
  include "../../config.php";
  if($_GET['view-source'] == 1) view_source();
?><html>
<head>
<title>Challenge 4</title>
<style type="text/css">
body { background:black; color:white; font-size:9pt; }
table { color:white; font-size:10pt; }
</style>
</head>
<body><br><br>
<center>
<?php
  sleep(1); // anti brute force
  if((isset($_SESSION['chall4'])) && ($_POST['key'] == $_SESSION['chall4'])) solve(4);
  $hash = rand(10000000,99999999)."salt_for_you";
  $_SESSION['chall4'] = $hash;
  for($i=0;$i<500;$i++) $hash = sha1($hash);
?><br>
<form method=post>
<table border=0 align=center cellpadding=10>
<tr><td colspan=3 style=background:silver;color:green;><b><?=$hash?></b></td></tr>
<tr align=center><td>Password</td><td><input name=key type=text size=30></td><td><input type=submit></td></tr>
</table>
</form>
<a href=?view-source=1>[view-source]</a>
</center>
</body>
</html>
```

소스 코드를 살펴보던 도중 처음 문제에 들어갔을때 봤던 문구는 sha1으로 암호화된 문구인 것을 알 수 있었다.

먼저 코드를 해석해보면  
if문을 통해 `key`값과 `chall4` 값을 비교하고 같으면 `solve(4)`가 실행이 된다.  
그다음에 `rand`함수를 통해 난수를 생성하고 이것을 `salt_for_you`라는 문구와 합쳐 `hash`값에 저장해준다.  
이 `hash`값을 chall4에 저장해주고 `for문`을 통해 500번 `sha1`으로 `hash`값을 암호화해준다.  

즉 이 문제를 해결하기 위해서는 500번 `sha1`으로 암호화하기 전 `hash` 값을 알아내야한다.

그러나 `sha1`은 단방향 해시함수로, 출력결과를 가지고 원본을 얻는 것이 불가능하다.

그래서 여기서 이용가능한 방법은 직접 10000000부터 99999999까지 500번 sha1으로 암호화시킨 후 레인보우 테이블을 만들어 직접 찾아주는 것이다.

다음과 같이 문제를 해결하기 위해 파이썬으로 코드를 작성했다.

```python
import hashlib

def sha1_encode(num):
    data = f"{num}salt_for_you"
    for i in range(0, 500):
        data = hashlib.sha1(data.encode('utf-8')).hexdigest()
    return data

f = open("Z:/잡동사니/공부/새파일.txt", 'w')
for i in range(10000000, 99999999):
    f.write(f"{i}: {sha1_encode(i)}\n")
f.close()
```

새파일이라는 메모장에 모든 값들을 저장시켰고 암호화된 문구와 비교를 해보았다.

`af7971ffb2e109fe7798cf034650c0541ef4ca3d`라는 값은 다음과 같다.

![](https://postfiles.pstatic.net/MjAyMDAxMTlfNTUg/MDAxNTc5NDE1ODY0ODMz.HjMcWJbVFLAnO3-UQBxdbBk5Ez5_hDtElyEqvlYzYnwg.7xf_sgA770emDIpZvfGnuncXdAgUmTEpr1jF_ciVLJ8g.JPEG.rlaeoghks823/K-083.jpg?type=w773)

패스워드에 `11970095salt_for_you`를 입력해주니 문제가 해결되었다.
