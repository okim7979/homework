## Shellcode (기계어로 작성된 프로그램)


일반적으로 어셈으로 작성 후 기계어로 변경  
실제 실행 가능한 프로그램이 아니라서 메모리상 배치나 세그먼트 등에 신경 안써도 된다.  
개발하기 위해서는 Assembly code에서 사용 가능한 system 함수들이 필요하다.  

## Assembly code

시스템 함수를 호출하기 위해 "int 0x80", "syscall" 명령어를 사용할 수 있다.  
System call 정보는 운영체제, 프로세서의 아키텍처 마다 다르다  
어셈블리로 시스템 함수을 호출 할 때는 시스템 콜 번호를 이용  
System call 번호는 EAX(32bit), RAX(64bit) 에 저장한다.

텍스트 세그먼트에 실제 어셈블리 명령이 있다.  
ELF바이너리를 생성하려면 링커에게 어셈블리 명령이 어디서부터 시작하는지 알려주는 global _start줄이 필요하다.

독자적으로 동작 가능한 코드 만들기 :  
-> data 세그먼트를 사용하지 않으므로 mov 명령어를 이용해 값을 전달 할 수 없다  
-> 위 문제는 call, ret 명령어를 사용해 해결 가능  
-> shellcode의 내용이 code 영역에 복사되게 해주기 위해선 null byte를 제거 해주어야한다.  

call 명령어의 null byte 제거해주기 :  
-> jmp short', 'call 음수' 명령어로 인해 null byte를 제거

## Register
64 bit, 32bit, 16 bit 레지스터에 표현 가능한 값보다 작은 값을 저장하게 되면 
나머지 공간은 null byte로 채워지게 된다.

shellcode에서 레지스터 영역을 사용하기 전 모든 영역을 0으로 초기화를 해주는것이 좋다.

>**1 sub  명령어를 이용한 초기화**  
sub 명령어는 연산 결과에 따라 OF, SF, ZF, AF, PF, CF flag의 값이 설정
이로 인해 *코드가 예상과 다르게 동작할 수 있다.*

>**2 xor 명령어를 이용한 초기화**  
xor 명령어가 sub 명령어 보다 flag에 영향을 덜 주기 때문에 xor을 이용해 레지스터 값을 초기화 하는 것이 *효율적*
