# Buffer Overflow Attack

## 0. 단어 뜻과 개념


커널 : 시스템의 모든 것을 완전히 통제한다, 
운영 체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러 가지 서비스를 제공

offset : 시작 위치

argc : 메인함수에 전달되는 정보의 갯수

argv : 이것은 메인함수에 전달되는 실질적인 정보로, 문자열의 배열을 의미한다. 
첫번째 문자열은 프로그램의 실행경로로 항상 고정이 되어 있다.


## 1. 8060 Memory Architecture


시스템은 운영에 필요한 기본적인 명령어 집합을 커널에서 찾기 때문에 커널은 메모리중
Low address 위치에 있어야 한다.

32bit 시스템 -> 메모리 영역에 주소를 할당할 수 있는 범위 0\~2^32-1  
64bit 시스템 -> 메모리 영역에 주소를 할당할 수 있는 범위 0\~2^64-1

하나의 프로세스 실행 -> 가용 메모리 영역에 segment 단위로 묶어서 저장
가용 메모리 영역에는 여러 개의 segment들이 저장 가능.

|**segment의 구조**|
|---|
|`Stack segment`|
|`Data segment`|
|`Code segment`|

###  code segment에는 시스템이 알아들을 수 있는 명령어들이 들어있다.
분기와 점프의 경우 특정 위치를 지정해 주어야 하지만, 컴파일 과정에는 자신이 현재 메모리상
어느 위치에 저장될지 모르기 때문에 정확한 주소를 지정 불가능.  
해결책 : logical address(실제 주소와 매칭되어 있다.)를 사용한다.  
segment selector에 의해 자신의 시작 위치(offset)을 찾을 수 있다.  
실제 메모리 주소(physical address) = offset + logical address

###  data segment에는 프로그램이 실행시에 사용되는 데이터<전역 변수>가 들어간다.
data segment = (data structure + 데이터 모듈 + 동적 생성 데이터 + 공유 데이터)

### stack segment는 우리가 사용하는 버퍼가 자리잡는다. -> 지역 변수들이 자리 잡는 공간
처음 생성될 때 필요한 크기만큼 만들어지고 프로세스의 명령에 의해 데이터를 저장해나간다.  
stack pointer는 스텍의 맨 꼭대기를 가르키고있다.  
따라서 스텍에 데이터를 저장하고 읽어들이는 명령어인
PUSH와 POP은 스텍 맨 꼭대기에 영향을 미친다.

## 2. 8086 cpu 레지스터 구조


CPU가 프로세스를 실행하기 위해서는 프로세스를 CPU에 적재시켜야한다.  
CPU 내부에 존재하는 메모리, 저장공간을 레지스터(register)라고 한다.

### 범용 레지스터
논리 연산, 수리 연산에 사용되는 피연산자, 주소를 계산하는데 사용되는 피연산자, 그리고 메모리 포인터가 저장되는 레지스터다.  
프로그래머가 임의로 조작할 수 있게 허용되어 있다.  
레지스터들은 프로그래머의 필요에 따라 아무렇게나 사용 가능하지만 나중의 편의성을 위해
그 목적대로 사용해 주는 것이 좋다.


### 세그먼트 레지스터
code segment, data segment, stack segment를 가리키는 주소가 들어있다.

| code segment | data segment | stack segment |
|:---:|:---:|:---:|
 `CS` | `DS ~ GS` | `SS`

### 플래그 레지스터
프로그램의 현재 상태나 조건 등을 검사하는데 사용되는 플래그들이 있는 레지스터.  
컨트롤 플래그 레지스터 = (상태 플래그 + 컨트롤 플래그 + 시스템 플래그)  
시스템이 리셋되어 초기화 되면 이 레지스터는 0x00000002의 값을 가진다.  
1,3,5,15,22~31비트는 예약되어 있어 조작 불가능.

### 인스트럭션 포인터(EIP 레지스터)
다음 수행해야 하는 명령이 있는 메모리 상의 주소가 들어있는 레지스터  
EIP 레지스터는 소프트웨어에 의해 바로 엑세스 할 수 없으므로 읽을 수 있는 방법은
CALL  명령어를 수행하고 나서 프로시저 스텍으로 부터 리턴하는 명령어의 주소를 읽는 것이다.

## 3. 프로그램 구동 시 Segment에서는 어떤 일이?

EIP는 main함수의 시작점을 가리키고 있다.  
ESP는 스텍의 맨 꼭대기를 가리키고 있다.

* ebp(base pointer)를 저장하는 이유 : 이전에 수행하던 함수의 데이터를 보존하기 위해

함수 프롤로그 과정 : stack pointer와 base pointer를 함수가 시작될 때 새로 지정한다.

call 0x80482f4 : 0x80482f4에 있는 명령을 수행하라는 것.  
call 명령은 함수를 호출할 때 사용되는 명령으로 함수 실행이 끝난 다음 이 후 명령 주소를 스텍에 넣고
EIP에 함수의 시작지점의 주소를 넣음. <- buffer overflow에서 가장 중요한 return address 이다.

>leave 명령어 : 함수 프롤로그를 되돌리는 작업을 수행한다.  
ret 명령어 : 이전 함수로  return하라는 의미.
